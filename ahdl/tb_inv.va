// ========================================================================
// Inverter Testbench - Verilog-A
// ========================================================================
// Tests CMOS inverter with all input combinations and transient edges
// to characterize propagation delay, rise/fall times, and switching energy.
//
// Test pattern:
//   - Exhaustive truth table: both input states (0, 1)
//   - Multiple transitions per state to measure tpd, tr, tf
//   - Realistic load capacitance (10fF - 100fF typical for logic)
// ========================================================================

`include "constants.vams"
`include "disciplines.vams"

module tb_inv;

// ========================================================================
// Parameters
// ========================================================================
parameter real VDD = 1.2;                    // Supply voltage (tech-dependent)
parameter real TPERIOD = 10n from (0:inf);   // Test period per state (10ns)
parameter real TRISE = 100p;                  // Input rise time (100ps)
parameter real TFALL = 100p;                  // Input fall time (100ps)
parameter real CLOAD = 20e-15;               // Load capacitance (20fF)
parameter integer NCYCLES = 4;               // Cycles per input state

// ========================================================================
// Signal declarations
// ========================================================================
electrical vdd_a, vss_a;
electrical in, out;

// Internal variables
integer state;                               // Current truth table state
integer cycle;                               // Cycle within current state
real t_state;                                // Time for current state
real t_in_state;                             // Time within current state
real vin_target;                             // Target voltage for input

// ========================================================================
// Power supplies
// ========================================================================
analog begin
    V(vdd_a) <+ VDD;
    V(vss_a) <+ 0.0;
end

// ========================================================================
// Input stimulus generation
// ========================================================================
analog begin
    @(initial_step) begin
        t_state = NCYCLES * TPERIOD;
    end

    // Determine current state and cycle
    state = floor($abstime / t_state);
    if (state > 1) state = 1;  // Clamp to valid range (2 states for 1 input)

    t_in_state = $abstime - state * t_state;
    cycle = floor(t_in_state / TPERIOD);
    if (cycle >= NCYCLES) cycle = NCYCLES - 1;

    // Generate input pattern based on state (truth table)
    // State 0: IN=0
    // State 1: IN=1
    case (state)
        0: begin
            vin_target = 0.0;
        end
        1: begin
            vin_target = VDD;
        end
    endcase

    // Apply input with realistic rise/fall times
    V(in) <+ transition(vin_target, 0, TRISE, TFALL);
end

// ========================================================================
// Load capacitance (at output)
// ========================================================================
analog begin
    I(out, vss_a) <+ ddt(CLOAD * V(out, vss_a));
end

// ========================================================================
// Device Under Test - Inverter
// ========================================================================
// Conditional instantiation based on cell type
`ifdef INV_STATIC
inv_static dut (
    .in(in),
    .out(out),
    .vdd_a(vdd_a),
    .vss_a(vss_a)
);
`else
// Default: inv_static
inv_static dut (
    .in(in),
    .out(out),
    .vdd_a(vdd_a),
    .vss_a(vss_a)
);
`endif

endmodule
