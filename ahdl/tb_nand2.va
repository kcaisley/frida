// ========================================================================
// NAND2 Gate Testbench - Verilog-A
// ========================================================================
// Tests 2-input NAND gate with all input combinations and transient edges
// to characterize propagation delay, rise/fall times, and switching energy.
//
// Test pattern:
//   - Exhaustive truth table: all input combinations
//   - Multiple transitions per combination to measure tpd, tr, tf
//   - Realistic load capacitance (10fF - 100fF typical for logic)
// ========================================================================

`include "constants.vams"
`include "disciplines.vams"

module tb_nand2;

// ========================================================================
// Parameters
// ========================================================================
parameter real VDD = 1.2;                    // Supply voltage (tech-dependent)
parameter real TPERIOD = 10n from (0:inf);   // Test period per state (10ns)
parameter real TRISE = 100p;                  // Input rise time (100ps)
parameter real TFALL = 100p;                  // Input fall time (100ps)
parameter real CLOAD = 20e-15;               // Load capacitance (20fF)
parameter integer NCYCLES = 4;               // Cycles per input combination

// ========================================================================
// Signal declarations
// ========================================================================
electrical vdd_a, vss_a;
electrical a, b, out;

// Internal variables
integer state;                               // Current truth table state
integer cycle;                               // Cycle within current state
real t_state;                                // Time for current state
real t_in_state;                             // Time within current state
real vin_a_target, vin_b_target;             // Target voltages for inputs

// ========================================================================
// Power supplies
// ========================================================================
analog begin
    V(vdd_a) <+ VDD;
    V(vss_a) <+ 0.0;
end

// ========================================================================
// Input stimulus generation
// ========================================================================
analog begin
    @(initial_step) begin
        t_state = NCYCLES * TPERIOD;
    end

    // Determine current state and cycle
    state = floor($abstime / t_state);
    if (state > 3) state = 3;  // Clamp to valid range (4 states for 2 inputs)

    t_in_state = $abstime - state * t_state;
    cycle = floor(t_in_state / TPERIOD);
    if (cycle >= NCYCLES) cycle = NCYCLES - 1;

    // Generate input patterns based on state (truth table)
    // State 0: A=0, B=0
    // State 1: A=0, B=1
    // State 2: A=1, B=0
    // State 3: A=1, B=1
    case (state)
        0: begin
            vin_a_target = 0.0;
            vin_b_target = 0.0;
        end
        1: begin
            vin_a_target = 0.0;
            vin_b_target = VDD;
        end
        2: begin
            vin_a_target = VDD;
            vin_b_target = 0.0;
        end
        3: begin
            vin_a_target = VDD;
            vin_b_target = VDD;
        end
    endcase

    // Apply inputs with realistic rise/fall times
    V(a) <+ transition(vin_a_target, 0, TRISE, TFALL);
    V(b) <+ transition(vin_b_target, 0, TRISE, TFALL);
end

// ========================================================================
// Load capacitance (at output)
// ========================================================================
analog begin
    I(out, vss_a) <+ ddt(CLOAD * V(out, vss_a));
end

// ========================================================================
// Device Under Test - NAND2 Gate
// ========================================================================
// Conditional instantiation based on cell type
`ifdef NAND2_STATIC
nand2_static dut (
    .a(a),
    .b(b),
    .out(out),
    .vdd_a(vdd_a),
    .vss_a(vss_a)
);
`else
// Default: nand2_static
nand2_static dut (
    .a(a),
    .b(b),
    .out(out),
    .vdd_a(vdd_a),
    .vss_a(vss_a)
);
`endif

endmodule
