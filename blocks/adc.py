"""
12-bit SAR ADC testbench specification.

This ADC is a hierarchical design from CDL netlists, not a transistor-level
circuit generated by the netlist tool. The testbench wraps the existing
adc.cdl subcircuit with appropriate stimulus.

The ADC operates at 10 Msps with:
- Differential inputs (vin_p, vin_n)
- Three power domains (analog, digital, DAC)
- Sequencer control signals (init, samp, comp, update)
- 64-bit DAC state buses for calibration
"""


def testbench():
    """
    ADC testbench for 2 complete conversions at 10 Msps.

    Timing: 10ns settling + 2x 100ns conversions = 210ns total
    Each conversion cycle:
      - 0-5ns: seq_init high
      - 5-15ns: seq_samp high
      - 15-100ns: seq_comp and seq_update alternate (2.5ns pulses)
    """

    # Generate DAC state bus signals (all tied high for normal operation)
    dac_buses = {}
    for bus in ['dac_astate_p', 'dac_astate_n', 'dac_bstate_p', 'dac_bstate_n']:
        for i in range(16):
            name = f'V{bus}{i}'
            dac_buses[name] = {
                'dev': 'vsource',
                'pins': {'p': f'{bus}[{i}]', 'n': 'gnd'},
                'wave': 'dc',
                'dc': 1.0
            }

    # Build DUT pin mapping for all 64 DAC state bits
    dut_pins = {
        'seq_init': 'seq_init', 'seq_samp': 'seq_samp',
        'seq_comp': 'seq_comp', 'seq_update': 'seq_update',
        'comp_out': 'comp_out',
        'en_init': 'en_init', 'en_samp_p': 'en_samp_p', 'en_samp_n': 'en_samp_n',
        'en_comp': 'en_comp', 'en_update': 'en_update',
        'dac_mode': 'dac_mode', 'dac_diffcaps': 'dac_diffcaps',
        'vin_p': 'vin_p', 'vin_n': 'vin_n',
        'vdd_a': 'vdd_a', 'vss_a': 'vss_a',
        'vdd_d': 'vdd_d', 'vss_d': 'vss_d',
        'vdd_dac': 'vdd_dac', 'vss_dac': 'vss_dac'
    }
    for bus in ['dac_astate_p', 'dac_bstate_p', 'dac_astate_n', 'dac_bstate_n']:
        for i in range(16):
            dut_pins[f'{bus}[{i}]'] = f'{bus}[{i}]'

    topology = {
        'testbench': 'tb_adc_12b',
        'devices': {
            # Analog supply
            'Vvdd_a': {'dev': 'vsource', 'pins': {'p': 'vdd_a', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Vvss_a': {'dev': 'vsource', 'pins': {'p': 'vss_a', 'n': 'gnd'}, 'wave': 'dc', 'dc': 0.0},

            # Digital supply
            'Vvdd_d': {'dev': 'vsource', 'pins': {'p': 'vdd_d', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Vvss_d': {'dev': 'vsource', 'pins': {'p': 'vss_d', 'n': 'gnd'}, 'wave': 'dc', 'dc': 0.0},

            # DAC supply
            'Vvdd_dac': {'dev': 'vsource', 'pins': {'p': 'vdd_dac', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Vvss_dac': {'dev': 'vsource', 'pins': {'p': 'vss_dac', 'n': 'gnd'}, 'wave': 'dc', 'dc': 0.0},

            # Differential input signals - ramping voltages
            # vin_p ramps from 1.1V to 1.05V, vin_n ramps from 0.8V to 0.85V
            'Vin_p': {
                'dev': 'vsource',
                'pins': {'p': 'vin_p', 'n': 'gnd'},
                'wave': 'pwl',
                'points': [0, 0.917, 210, 0.875]  # 1.1/1.2 and 1.05/1.2 normalized
            },
            'Vin_n': {
                'dev': 'vsource',
                'pins': {'p': 'vin_n', 'n': 'gnd'},
                'wave': 'pwl',
                'points': [0, 0.667, 210, 0.708]  # 0.8/1.2 and 0.85/1.2 normalized
            },

            # Sequencer timing signals (10ns settling, then 100ns conversion periods)
            # seq_init: 5ns pulse at start of each conversion
            'Vseq_init': {
                'dev': 'vsource',
                'pins': {'p': 'seq_init', 'n': 'gnd'},
                'wave': 'pulse',
                'v1': 0, 'v2': 1.0, 'td': 10, 'tr': 0.1, 'tf': 0.1, 'pw': 4.8, 'per': 100
            },

            # seq_samp: 10ns pulse starting 5ns into conversion
            'Vseq_samp': {
                'dev': 'vsource',
                'pins': {'p': 'seq_samp', 'n': 'gnd'},
                'wave': 'pulse',
                'v1': 0, 'v2': 1.0, 'td': 15, 'tr': 0.1, 'tf': 0.1, 'pw': 9.8, 'per': 100
            },

            # seq_comp: 2.5ns high, 2.5ns low alternating (5ns period, starts at 25ns)
            'Vseq_comp': {
                'dev': 'vsource',
                'pins': {'p': 'seq_comp', 'n': 'gnd'},
                'wave': 'pulse',
                'v1': 0, 'v2': 1.0, 'td': 25, 'tr': 0.1, 'tf': 0.1, 'pw': 2.4, 'per': 5
            },

            # seq_update: 2.5ns high, 2.5ns low alternating (5ns period, starts at 27.5ns)
            'Vseq_update': {
                'dev': 'vsource',
                'pins': {'p': 'seq_update', 'n': 'gnd'},
                'wave': 'pulse',
                'v1': 0, 'v2': 1.0, 'td': 27.5, 'tr': 0.1, 'tf': 0.1, 'pw': 2.4, 'per': 5
            },

            # Enable signals - tied high for normal operation
            'Ven_init': {'dev': 'vsource', 'pins': {'p': 'en_init', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Ven_samp_p': {'dev': 'vsource', 'pins': {'p': 'en_samp_p', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Ven_samp_n': {'dev': 'vsource', 'pins': {'p': 'en_samp_n', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Ven_comp': {'dev': 'vsource', 'pins': {'p': 'en_comp', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Ven_update': {'dev': 'vsource', 'pins': {'p': 'en_update', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},

            # DAC mode control signals
            'Vdac_mode': {'dev': 'vsource', 'pins': {'p': 'dac_mode', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},
            'Vdac_diffcaps': {'dev': 'vsource', 'pins': {'p': 'dac_diffcaps', 'n': 'gnd'}, 'wave': 'dc', 'dc': 1.0},

            # DUT instance
            'Xadc': {'dev': 'adc', 'pins': dut_pins}
        },
        'analyses': {
            'tran1': {
                'type': 'tran',
                'stop': 210,
                'step': 0.1
            }
        },
        'extra_includes': [
            # Standard cell libraries (TSMC65 specific)
            '/eda/kits/TSMC/65LP/2024/digital/Back_End/spice/tcbn65lplvt_200a/tcbn65lplvt_200a.spi',
            '/eda/kits/TSMC/65LP/2024/digital/Back_End/spice/tcbn65lp_200a/tcbn65lp_200a.spi',
            # ADC sub-module netlists
            'spice/sampswitch.cdl',
            'spice/comp.cdl',
            'spice/capdriver.cdl',
            'spice/caparray.cdl',
            'spice/adc_digital.cdl',
            'spice/adc.cdl'
        ],
        'save': [
            'v(vin_p)', 'v(vin_n)', 'v(comp_out)',
            'v(seq_init)', 'v(seq_samp)', 'v(seq_comp)', 'v(seq_update)',
            'v(en_init)', 'v(en_samp_p)', 'v(en_samp_n)', 'v(en_comp)', 'v(en_update)'
        ]
    }

    # Add DAC state bus sources
    topology['devices'].update(dac_buses)

    return topology


def measure(raw, netlist, raw_file):
    """
    Measure ADC linearity from simulation results.
    
    This function:
    1. Extracts differential input voltage
    2. Digitizes ADC output bits
    3. Reconstructs analog output using weights
    4. Calculates INL and DNL (both step-based and histogram methods)
    5. Saves all results for plotting
    """
    from flow.measure import (
        digitize, reconstruct_analog, calculate_inl, calculate_dnl,
        calculate_dnl_histogram, calculate_linearity_error,
        round_to_codes, write_analysis
    )
    import numpy as np
    
    # Load simulation data
    time = raw.get_axis()
    vin_p = raw.get_wave('v(vin_p)')
    vin_n = raw.get_wave('v(vin_n)')
    vin = vin_p - vin_n  # Differential input
    
    # Get digital output bits from ADC
    # TODO: Update these signal names based on actual ADC outputs
    # For now, assuming comp_out is the comparator output
    comp_out = raw.get_wave('v(comp_out)')
    
    # Define ADC parameters
    n_bits = 12  # 12-bit ADC
    vdd = 1.0  # Supply voltage
    
    # Digitize comparator output
    comp_digital = digitize(comp_out, vdd=vdd)
    
    # TODO: Extract actual DAC state bits when available from simulation
    # For now, create placeholder digital code array
    # This should be replaced with actual bit extraction like:
    # dcode = np.zeros((len(time), n_bits))
    # for i in range(n_bits):
    #     dcode[:, i] = digitize(raw.get_wave(f'v(dac_bit_{i})'), vdd=vdd)
    
    # Define weights for 12-bit binary ADC
    radix = 2.0
    weights = np.array([radix**i for i in range(n_bits)])
    
    # For now, create synthetic digital code based on input
    # TODO: Replace with actual ADC output extraction
    vref_range = (-0.6, 0.6)  # ADC input range
    vin_normalized = np.clip(vin, vref_range[0], vref_range[1])
    
    # Reconstruct analog output from digital code (placeholder until real bits available)
    # dout_analog = reconstruct_analog(dcode, weights, vref_range=vref_range)
    dout_analog = vin_normalized  # Placeholder
    
    # Round to discrete codes
    dout_rounded = round_to_codes(dout_analog)
    
    # Calculate INL (Integral Nonlinearity)
    inl, inl_rms, inl_max = calculate_inl(vin, dout_analog, return_stats=True)
    
    # Calculate DNL using both methods
    # Method 1: Step-based DNL
    dnl, dnl_rms, dnl_max = calculate_dnl(dout_analog, return_stats=True)
    
    # Method 2: Histogram-based DNL (code density)
    dnl_hist, code_counts, dnl_hist_rms, dnl_hist_max = calculate_dnl_histogram(
        dout_analog, return_stats=True
    )
    
    # Calculate linearity error
    linearity_error, error_rms = calculate_linearity_error(vin, dout_analog, return_stats=True)
    
    # Print summary statistics
    print(f"\nADC Linearity Analysis Results:")
    print(f"  INL RMS: {inl_rms:.4f} LSB")
    print(f"  INL Max: {inl_max:.4f} LSB")
    print(f"  DNL RMS (step-based): {dnl_rms:.4f} LSB")
    print(f"  DNL Max (step-based): {dnl_max:.4f} LSB")
    print(f"  DNL RMS (histogram): {dnl_hist_rms:.4f} LSB")
    print(f"  DNL Max (histogram): {dnl_hist_max:.4f} LSB")
    print(f"  Linearity Error RMS: {error_rms:.4f}")
    
    # Save all results (arrays + scalars) for plotting
    write_analysis(
        raw_file,
        time, vin, vin_p, vin_n, comp_digital,
        dout_analog, dout_rounded, inl, dnl, linearity_error,
        inl_rms, inl_max, dnl_rms, dnl_max,
        dnl_hist_rms, dnl_hist_max, error_rms
    )
    
    print(f"\nAnalysis complete. Results saved to {raw_file}.pkl and {raw_file}.raw_a")
