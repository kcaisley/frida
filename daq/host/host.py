# FRIDA Host Controller
#
# PC-side control interface for the FRIDA ADC chip. Communicates with the
# FPGA via basil/SiTcp to configure the chip and run measurements.
#
# Based on:
#   - obelix1-daq/obelix1/system/obelix.py (main structure)
#   - CordiaADC/ADC_01/host/ADC01.py (ADC-specific patterns)
#   - CordiaADC/ADC_01/host/meas_config.py (sequencer setup)
#
# Signal names match PCB schematic: frida/pcb/frida65A.kicad_sch

from __future__ import annotations

import logging
import time
from pathlib import Path
from typing import TYPE_CHECKING

import numpy as np
import yaml
from bitarray import bitarray

if TYPE_CHECKING:
    from basil.dut import Dut

logger = logging.getLogger(__name__)

# Constants
N_ADCS = 16
SPI_BITS = 180
CONVERSION_PERIOD_NS = 100  # 10 Msps
N_COMP_BITS = 17  # 17-bit SAR ADC


class Frida:
    """Interface for the FRIDA ADC test chip.

    The FRIDA chip contains 16 SAR ADCs with a shared 180-bit SPI
    configuration register. Timing is controlled by 4 LVDS clock signals
    generated by the FPGA sequencer, plus 2 additional sequencer tracks
    for COMP_OUT capture control (CLK_COMP_CAP and SEN_COMP).

    Attributes:
        daq: Basil Dut object for hardware communication
        spi_bits: Current state of the 180-bit SPI register
    """

    def __init__(self, daq: Dut):
        """Initialize FRIDA chip interface.

        Args:
            daq: Initialized Basil Dut object (from map_fpga.yaml)
        """
        self.daq = daq
        self.spi_bits = bitarray(SPI_BITS)
        self.spi_bits.setall(0)

        # Load register definitions
        reg_path = Path(__file__).parent / "map_dut.yaml"
        with open(reg_path) as f:
            self._registers = yaml.safe_load(f)

    def init(self) -> None:
        """Initialize the chip for operation.

        Performs:
            1. Assert reset
            2. Configure sequencer with default timing
            3. Enable fast_spi_rx for COMP_OUT capture
            4. Release reset
            5. Load default SPI configuration
        """
        logger.info("Initializing FRIDA chip")

        # Assert reset via GPIO
        self.daq["gpio"]["RST_B"] = 0
        self.daq["gpio"].write()
        time.sleep(0.01)

        # Configure sequencer with default conversion timing
        self._configure_sequencer()

        # Enable fast_spi_rx for COMP_OUT capture
        self.daq["fast_spi_rx"].reset()
        self.daq["fast_spi_rx"].set_en(True)

        # Release reset
        self.daq["gpio"]["RST_B"] = 1
        self.daq["gpio"].write()
        time.sleep(0.01)

        # Load default configuration
        self.write_spi()

        logger.info("FRIDA initialization complete")

    def reset(self) -> None:
        """Perform a hardware reset of the chip."""
        logger.info("Resetting FRIDA chip")
        self.daq["gpio"]["RST_B"] = 0
        self.daq["gpio"].write()
        time.sleep(0.01)
        self.daq["gpio"]["RST_B"] = 1
        self.daq["gpio"].write()
        time.sleep(0.01)

    # -------------------------------------------------------------------------
    # Input Amplifier Control
    # -------------------------------------------------------------------------

    def set_amplifier_enabled(self, enabled: bool) -> None:
        """Enable or disable the input amplifier buffer on the PCB.

        Based on:
            - frida/pcb/frida65A.kicad_sch (AMP_EN signal)

        The PCB has an optional differential amplifier (THS4520) between
        the external input and the chip's VIN_P/VIN_N pins. When disabled,
        the amplifier is powered down (~14mA savings) and the input is
        bypassed directly to the chip.

        Args:
            enabled: True to enable amplifier, False to bypass/power-down
        """
        self.daq["gpio"]["AMP_EN"] = 1 if enabled else 0
        self.daq["gpio"].write()
        logger.info(f"Input amplifier {'enabled' if enabled else 'disabled (bypass)'}")

    def enable_amplifier(self) -> None:
        """Enable the input amplifier buffer."""
        self.set_amplifier_enabled(True)

    def disable_amplifier(self) -> None:
        """Disable the input amplifier buffer (bypass mode, saves ~14mA)."""
        self.set_amplifier_enabled(False)

    # -------------------------------------------------------------------------
    # SPI Register Access
    # -------------------------------------------------------------------------

    def set_register(self, name: str, value: int) -> None:
        """Set a register value in the local SPI bit array.

        Args:
            name: Register name from map_dut.yaml
            value: Value to set
        """
        if name not in self._registers:
            raise ValueError(f"Unknown register: {name}")

        reg = self._registers[name]
        offset = reg["offset"]
        size = reg["size"]

        # Set bits in the local array
        for i in range(size):
            bit_val = (value >> i) & 1
            self.spi_bits[offset + i] = bit_val

    def get_register(self, name: str) -> int:
        """Get a register value from the local SPI bit array.

        Args:
            name: Register name from map_dut.yaml

        Returns:
            Current register value
        """
        if name not in self._registers:
            raise ValueError(f"Unknown register: {name}")

        reg = self._registers[name]
        offset = reg["offset"]
        size = reg["size"]

        value = 0
        for i in range(size):
            if self.spi_bits[offset + i]:
                value |= 1 << i
        return value

    def write_spi(self) -> None:
        """Write the current SPI bit array to the chip.

        Shifts all 180 bits into the chip's shift register.
        """
        logger.debug("Writing SPI configuration to chip")

        # Convert bitarray to bytes (LSB first)
        data = self.spi_bits.tobytes()

        # Use basil SPI driver to shift out the data
        self.daq["spi"].set_data(data)
        self.daq["spi"].set_size(SPI_BITS)
        self.daq["spi"].start()

        # Wait for transfer to complete
        while not self.daq["spi"].is_ready:
            pass

    def read_spi(self) -> bitarray:
        """Read back the SPI register contents from the chip.

        Returns:
            180-bit array read from chip
        """
        logger.debug("Reading SPI configuration from chip")

        # Shift out zeros while reading back
        data = bytes(SPI_BITS // 8 + 1)
        self.daq["spi"].set_data(data)
        self.daq["spi"].set_size(SPI_BITS)
        self.daq["spi"].start()

        while not self.daq["spi"].is_ready:
            pass

        # Get received data
        rx_data = self.daq["spi"].get_data(SPI_BITS // 8 + 1)
        result = bitarray()
        result.frombytes(bytes(rx_data))
        return result[:SPI_BITS]

    # -------------------------------------------------------------------------
    # ADC Configuration
    # -------------------------------------------------------------------------

    def select_adc(self, adc_num: int) -> None:
        """Select which ADC output appears on COMP_OUT.

        Args:
            adc_num: ADC index (0-15)
        """
        if not 0 <= adc_num < N_ADCS:
            raise ValueError(f"ADC number must be 0-15, got {adc_num}")

        self.set_register("MUX_SEL", adc_num)
        logger.info(f"Selected ADC {adc_num}")

    def enable_adc(
        self,
        adc_num: int,
        en_init: bool = True,
        en_samp_p: bool = True,
        en_samp_n: bool = True,
        en_comp: bool = True,
        en_update: bool = True,
        dac_mode: bool = False,
        dac_diffcaps: bool = False,
    ) -> None:
        """Configure an individual ADC channel.

        Args:
            adc_num: ADC index (0-15)
            en_init: Enable initialization phase
            en_samp_p: Enable positive sampling
            en_samp_n: Enable negative sampling
            en_comp: Enable comparator
            en_update: Enable DAC update
            dac_mode: DAC operation mode
            dac_diffcaps: DAC differential capacitor mode
        """
        if not 0 <= adc_num < N_ADCS:
            raise ValueError(f"ADC number must be 0-15, got {adc_num}")

        value = (
            (int(en_init) << 0)
            | (int(en_samp_p) << 1)
            | (int(en_samp_n) << 2)
            | (int(en_comp) << 3)
            | (int(en_update) << 4)
            | (int(dac_mode) << 5)
            | (int(dac_diffcaps) << 6)
        )

        self.set_register(f"ADC_{adc_num}", value)
        logger.debug(f"Configured ADC {adc_num}: 0x{value:02x}")

    def enable_all_adcs(self) -> None:
        """Enable all 16 ADCs with default settings."""
        for i in range(N_ADCS):
            self.enable_adc(i)
        logger.info("Enabled all 16 ADCs")

    def disable_all_adcs(self) -> None:
        """Disable all 16 ADCs."""
        for i in range(N_ADCS):
            self.set_register(f"ADC_{i}", 0)
        logger.info("Disabled all 16 ADCs")

    def set_dac_state(
        self,
        astate_p: int = 0,
        bstate_p: int = 0,
        astate_n: int = 0,
        bstate_n: int = 0,
    ) -> None:
        """Set the shared DAC initial states for all ADCs.

        Args:
            astate_p: A-state positive (16-bit)
            bstate_p: B-state positive (16-bit)
            astate_n: A-state negative (16-bit)
            bstate_n: B-state negative (16-bit)
        """
        self.set_register("DAC_ASTATE_P", astate_p & 0xFFFF)
        self.set_register("DAC_BSTATE_P", bstate_p & 0xFFFF)
        self.set_register("DAC_ASTATE_N", astate_n & 0xFFFF)
        self.set_register("DAC_BSTATE_N", bstate_n & 0xFFFF)

    # -------------------------------------------------------------------------
    # Sequencer Configuration
    # -------------------------------------------------------------------------

    def _configure_sequencer(
        self,
        conversion_period_ns: int = CONVERSION_PERIOD_NS,
        seq_clk_period_ns: float = 5.0,
        capture_delay_steps: int = 1,
    ) -> None:
        """Configure the sequencer for ADC timing.

        Sets up the 6 sequencer tracks:
        - CLK_INIT, CLK_SAMP, CLK_COMP, CLK_LOGIC: LVDS clock outputs to chip
        - CLK_COMP_CAP: Capture clock for fast_spi_rx (samples COMP_OUT)
        - SEN_COMP: Frame enable for fast_spi_rx (high during 17 capture cycles)

        Args:
            conversion_period_ns: Total conversion time in ns (default 100ns = 10 Msps)
            seq_clk_period_ns: Sequencer clock period in ns (default 5ns = 200 MHz)
            capture_delay_steps: Steps to delay CLK_COMP_CAP for propagation compensation
        """
        from .sequences import generate_conversion_sequence

        seq_data = generate_conversion_sequence(
            conversion_period_ns=conversion_period_ns,
            seq_clk_period_ns=seq_clk_period_ns,
            capture_delay_steps=capture_delay_steps,
        )

        # Load sequence into FPGA - all 6 tracks
        self.daq["SEQ"]["CLK_INIT"][: len(seq_data["CLK_INIT"])] = bitarray(
            seq_data["CLK_INIT"]
        )
        self.daq["SEQ"]["CLK_SAMP"][: len(seq_data["CLK_SAMP"])] = bitarray(
            seq_data["CLK_SAMP"]
        )
        self.daq["SEQ"]["CLK_COMP"][: len(seq_data["CLK_COMP"])] = bitarray(
            seq_data["CLK_COMP"]
        )
        self.daq["SEQ"]["CLK_LOGIC"][: len(seq_data["CLK_LOGIC"])] = bitarray(
            seq_data["CLK_LOGIC"]
        )
        self.daq["SEQ"]["CLK_COMP_CAP"][: len(seq_data["CLK_COMP_CAP"])] = bitarray(
            seq_data["CLK_COMP_CAP"]
        )
        self.daq["SEQ"]["SEN_COMP"][: len(seq_data["SEN_COMP"])] = bitarray(
            seq_data["SEN_COMP"]
        )
        self.daq["SEQ"].write()

        # Configure sequencer timing
        self.daq["seq"].set_size(len(seq_data["CLK_INIT"]))
        self.daq["seq"].set_clk_divide(1)  # No division, use PLL clock directly

        logger.info(
            f"Sequencer configured: {conversion_period_ns}ns conversion, "
            f"{len(seq_data['CLK_INIT'])} steps"
        )

    # -------------------------------------------------------------------------
    # Data Acquisition
    # -------------------------------------------------------------------------

    def run_conversions(self, n_conversions: int, repetitions: int = 1) -> np.ndarray:
        """Run ADC conversions and collect comparator output data.

        The fast_spi_rx module captures COMP_OUT data with the following format:
        - Each 32-bit FIFO word contains: [31:28] IDENTIFIER, [27:16] frame_cnt, [15:0] data
        - For 17-bit conversions: first 16 bits → one word, remaining 1 bit → partial word

        Args:
            n_conversions: Number of conversion cycles to run
            repetitions: Number of times to repeat the sequence

        Returns:
            Array of comparator outputs, shape (repetitions, n_conversions, n_bits)
        """
        logger.info(f"Running {n_conversions} conversions x {repetitions} reps")

        # Configure sequencer for requested number of conversions
        self.daq["seq"].set_size(n_conversions * 20)  # 20 steps per conversion
        self.daq["seq"].set_repeat(repetitions)

        # Reset fast_spi_rx to clear any stale data
        self.daq["fast_spi_rx"].reset()
        self.daq["fast_spi_rx"].set_en(True)

        # Clear FIFO
        self.daq["fifo"].reset()

        # Enable external start and trigger
        self.daq["seq"].set_en_ext_start(True)
        self.daq["pulse_gen"].set_delay(1)
        self.daq["pulse_gen"].set_width(1)
        self.daq["pulse_gen"].start()

        # Wait for completion
        while not self.daq["seq"].is_ready:
            time.sleep(0.001)

        # Read data from FIFO
        # Each conversion produces 2 words (16 bits + 1 bit partial)
        n_words = n_conversions * repetitions * 2
        n_bytes = n_words * 4  # 32-bit words
        raw_data = self.daq["fifo"].get_data(n_bytes)

        # Parse the fast_spi_rx output format
        words = np.frombuffer(raw_data, dtype=np.uint32)
        data = self._parse_fast_spi_rx_data(words, n_conversions, repetitions)

        # Check for lost data
        lost_count = self.daq["fast_spi_rx"].get_lost_count()
        if lost_count > 0:
            logger.warning(f"fast_spi_rx lost {lost_count} words due to FIFO overflow")

        logger.info(f"Acquired {data.size} samples")
        return data

    def _parse_fast_spi_rx_data(
        self, words: np.ndarray, n_conversions: int, repetitions: int
    ) -> np.ndarray:
        """Parse fast_spi_rx FIFO data into ADC conversion results.

        The fast_spi_rx output format (32-bit words):
            [31:28] IDENTIFIER (4'b0001)
            [27:16] Frame counter (12 bits)
            [15:0]  Captured data (16 bits)

        For 17-bit ADC conversions:
            - Word 0: Contains bits 0-15 of the conversion
            - Word 1: Contains bit 16 (in LSB position), padded with zeros

        Args:
            words: Raw 32-bit words from FIFO
            n_conversions: Number of conversion cycles
            repetitions: Number of repetitions

        Returns:
            Array of shape (repetitions, n_conversions) with 17-bit ADC codes
        """
        # Extract data field from each word (lower 16 bits)
        data_fields = words & 0xFFFF

        # Each conversion produces 2 words
        n_total = n_conversions * repetitions
        result = np.zeros(n_total, dtype=np.uint32)

        for i in range(n_total):
            word_idx = i * 2
            if word_idx + 1 < len(data_fields):
                # Combine: first word has bits 0-15, second word has bit 16
                result[i] = data_fields[word_idx] | (
                    (data_fields[word_idx + 1] & 0x1) << 16
                )

        return result.reshape(repetitions, n_conversions)

    def measure_transfer_function(
        self,
        adc_num: int,
        n_samples: int = 100,
        n_repetitions: int = 10,
    ) -> dict:
        """Measure the ADC transfer function.

        Sweeps the input voltage and measures ADC output codes.

        Args:
            adc_num: ADC to measure (0-15)
            n_samples: Number of input voltage steps
            n_repetitions: Repetitions per voltage step

        Returns:
            Dictionary with 'vin' and 'codes' arrays
        """
        logger.info(f"Measuring transfer function for ADC {adc_num}")

        self.select_adc(adc_num)
        self.enable_adc(adc_num)
        self.write_spi()

        # This is a placeholder - actual implementation depends on
        # external voltage source control (e.g., SMU via VISA)
        codes = self.run_conversions(n_samples, n_repetitions)

        return {
            "adc": adc_num,
            "codes": codes,
        }
