

It includes DRC and LVS rules, SPICE models, technology files, verification and extraction files, execution scripts, symbol library and parametric cells (PCells)

OpenAccess file format comes with APIs for C++, C#, Perl, Python, Ruby and Tcl.

[Blog describing some issues](https://semiwiki.com/x-subscriber/silvaco/5601-custom-ic-design-flow-with-openaccess/)

Interoperable PDK (iPDK) came from TSMC starting in 2007, and by 2009 the first 65nm iPDK was ready. The iPDK Alliance called IPL controls the iPDK specification and members include: Altera (Intel), Ciranova, Mentor Graphics, Pulsic, SpringSoft, Synospys and TSM with Xilinx and STMicroelectronics as advisors. With iPDK the foundry and partners spend less time on PDK development. The Interoperable PDK Libraries Alliance (IPL), working with TSMC, standardized on using Ciranova’s PyCell approach (based on Python rather than SKILL) and created the iPDK which is supported by all the layout editors (even Virtuoso, at least unofficially).

As with much in the EDA industry, there will be multiple standards so OpenPDK is yet another approach, this time from Si2.org, using an XML structured file and translators for main vendor tools. Each supplier creates their own parser to create the standardized exchange format. An OPDK can also create an iPDK. There is a second portable PDK standard anyway called OpenPDK, being done under the umbrella of Si2, although the work just started last year and hasn’t yet delivered actual PDKs. Supported by Global foundaries. Si2 is perceived by other EDA vendors as being too close to Cadence (they also nurture OpenAccess and CPF, which both started off internally inside Cadence)


All of this IC design reuse sounds really promising and liberating, however there are some issue for you to aware of. There can be subtle differences between Cadence PDK (using Skill), iPDK (Tcl), custom PDK (Tcl, Python, Perl). 

tsmcn65 ivpcell
What is a ivpcell?



[From Si2 website](https://si2.org/os-downloads/):

OpenPDK Coalition

The OpenPDK (Process Design Kit) Coalition was founded in 2010 to define a set of open standards allowing an OpenPDK to be created (once) and translated into specific EDA vendor tools and foundry formats. This allows for maximum portability across foundries and agnosticism among EDA tools. The Si2 OpenPDK standard enables greater efficiency in PDK development, verification, and delivery, providing equal support to foundries, EDA tool vendors, IP providers, and end-users.

Specifications

    OpenPDK Open Process Specification (OPS): This specification enables foundries to study and create electronic versions of DRM and to gather early feedback on completeness.
    OPS 1.2 supports the creation of a techfile/oaTech.db for foundry-specific layer information. This includes grids, connectivity, display information, and version information. This release also integrates the Device Parameters (previously called Design Parameters) and Tool Interface standards into OPS.
    OpenPDK PCell Standard (PCell v1.0 is compatible with OPS 1.2)
    OpenPDK Design Parameter and Callback Specification V1.0
    OpenPDK Schematic Symbol Standard V1.0


The term "callback" is used for a number of different situations, but in general it's a means of having a function that gets called when some kind of event occurs. In this case it's called when the simulation finishes. In some cases the callback is a complete SKILL expression which is just evaluated using evalstring, but in others you provide the name of the function to call (or in an increasing number of cases, you can also provide the function object which is beneficial when using SKILL++). In this case you're doing just that - providing the name of the function to call.

# Opensource EDA in Europe
The US isn't dominating contributions to open source EDA. OpenROad -> OpenLane is US based but..
Actually, the many of the important and essential tools in open source EDA are fundamentally being developed in Europe (e.g. klayout (Munich), yosys (Vienna), nextpnr (Vienna/Heidelberg), ngspice (Duisburg)).


# Parasitic extraction

Parasitic extraction yeilds something called a DSPF file, or Detailed Standard Parasitic Format
It's a spice netlists generated by StarRC, QRC, Calibre, etc which is directly simulatable with design devices and parasitic devices
It's not a standardized format, unlike [SPEF](https://en.wikipedia.org/wiki/Standard_Parasitic_Exchange_Format) which is IEEE standardized


# Notes from Jun 25, 2024:

This idea of having 'procedural generators', with parameterizable and verified layout+models is (in a limited way) essentially what a PCell is. Now, there isn't a direct hook to run a simulations and plotting, but as long as you can overtime develop the model with your own manually triggered simulations, in the end you have a

PyCells support process portability, by allowing for 'correct-by-construction' functions which take a technology description as input, and for example place two transistors 'as-close-as-possible'.

PyCells don't allow themselves for parameterized batch simulation, but the standard testbenching tools from Cadence e.g. will let you sweep any parameter exposed by the Pcell


 

## Alternative layout strategies:

Layouts can be generated via a host of different methods. Here is short summary:

- **Skill PCell**, written in Virtuoso embedded LISP dialect Skill. When imported, it becomes a OA PCell which is viewable in the Cadence library viewer.
- **PyCell**, developer by Ciranova and acquired by Synopsys, these are available via the IPL iPDK alliances and allow creation of OA PCells. They appear as a line item in a Cadence, Synopsys, and Siemens library viewer, but don't compile down to binary OA Pcells. Instead they rely on Python at runtime to call the C++ implementation of OA. Can be developed in PyCell studio.
- **Skill Interface** Some tools work by sending commands over Virtuoso's Skill interface. The two prime examples are SkillBridge and BAG2.Laygo2 also supports this. They have no resting date format, and rely on Skill/Virtuoso at runtime.
- **Dump to GDS** Many open source tools rely on writing raw GDS. They include Laygo2, Substrate2, Layout21, 
- **
tcl pcell
bag3 raw oa output
klayout python/ruby pcell
how does synopsys really do pcells natively?
magic vlsi

What's important is to have the a device model tuned to device dimensions, and to be able to keep these in sync.

From [this thesis, page 57:](https://archiv.ub.uni-heidelberg.de/volltextserver/30559/)

> Besides the PyCell code, it is necessary to provide a technology file to the cngenlib command to generate the OpenAccess database library for Virtuoso. This technology file is also needed to display the layers within PyCell Studio and has to be in the "Santana" format

> The parent directory to the directory with the PyCell code has to be added to the $PYTHONPATH environment variable. If this is not done correctly, Virtuoso cannot find the PyCell.

> The $OA_PLUGIN_PATH environment variable contains the paths to Virtuoso plugins(.plg). It should be set correctly by sourcing the PyCell Studio script.

> The gcc version of the PyCell Studio and the system running Virtuoso should match to properly use the PyCells.

From [LayoutEditor docs](https://layouteditor.org/layout/basics/installation) I found:

> Synopsys provides packages created with different compilers. Packages generated by a new compiler may cause problems if not used by your system. So for RHEL package until version 7, and Ubuntu package until version 16.04, please use PyCell installations for gcc48x. Starting with RHEL8 and Ubuntu 18.04, packages generated with gcc62 will work. The PyCell installer may see several error messages on Ubuntu-based systems, nevertheless mostly it is installed correctly. If it is not done, try to set the compiler version manual: export OA_COMPILER="gcc62" before starting the PyCell installer.


From [LayoutEditor Wiki:](http://www.layouteditor.net/wiki/iPDK)

- OpenAccess can store layout data, schematics, symbols, netlists and any other application specific data. These information are stored into many files in a directory tree.
- IPL iPDKs are based on OpenAcess and glued together with Python and TCL
- Technology files include .drf, CdsTech Virtuoso ASCII file, OA libs.def or OA cds.lib
- Some iPKDs (e.g. many PDKs from TSMC) come with an own version of PyCell and run only with this version correctly. If that is the case for your PDK, please use the PyCell version shipped by your foundery. In this case:
- As PyCell isn't in the default location `/opt/synopsys`, one must use `$CNI_ROOT` and probably also `$LD_LIBRARY_PATH`
-  `lib.defs` is the main configuration file for OpenAccess
- In iPDKs, TCL is typically used for the callback functions, which for example are used to calculate a capacitor's new value after changing the width or length.
- An other known problem is that some founderies use an extended Tcl API and implement these extended calls for some tools. So the 'iPDK' becomes incompatible to other tools. The extensions needs to implement for the LayoutEditor was well to use the iPDK. As an example for this problem the TowerJazz iPDKs use an API call iPDK_getParamList which is not part of the original iPDK specification. To use this iPDK with the LayoutEditor an additional Tcl file had to be included into the callback folder
- Layer definitions can come from either `tech.db` file, `Santana.tech` and or from the `layer.map` file


[text](https://spdocs.synopsys.com/dow_retrieve/latest/dg/pycell/pycell_olh/olh_pycell/pycell_studio_documentation.html)


# June 25, dialog on Pycells

What is happening here?

iPDK hasn't been updated in two years by synopsys, and the version for OA 22.60 is only supported in Synopsys tools, while Cadence and Siememsn are still stuk on version 22.50 which only supports RHEL7 and Python 2.

The si2 coalition hasn't posted anything in 2 years, on their block

The IPL alliance doesn't appear to exist anymore?

Jürgen Thies at layout edito

Dr. Lan wei, professor at uni-waterloo

September 9-12, 2024, ESSERC meeting in brudges.... appears to also have MOS-AK meeting going on there (which is different than CMC)

Maybe also tried somebody via:
IMEC
Europratice?
CERN - no, they didn't understand where models came from?

online? 

My research question focuses on the design of detector and readout circuits for high-energy particle imaging.

The first section of my thesis focuses on layout and schematic generation and parametrization and optimization, with an extensive discussion on the general approaches of procedural vs constraint&optimization


Can OA PCells be used during the initial device design, to vary many different parameters? I believe in this case, it is limited to parametric layout generation, with pointers to a compact models which takes the same input params for corresponding simulation.

Can OA PCells be used to encapsulate the layouts of multi-device circuits?

Is the process of loading layout masks from OA or GDS into a TCAD simulator fairly easy?

Will OA PCells essentially function as compiled generators? I understand that they can't call out to simulators, and so how do simulation models get associated? Let's say you've compiled a PCell which changes dimensions of a device layout, and

How would Verilog-A fit into this model? I believe the vein here would be to create a numerically efficient fit behavioral model, but this would be a final step. And it's initially mainly useful to move away from 'multi-model' simulation between TCAD and SPICE, by creating an IV model for the detector.

How can simulation results be packaged with and associated with these devices? For SPICE-level simulation the eventually simulation format need to be compact models with a hierarchical netlist.

The fundamental struggle of monolithic active pixel design is that you are assembling on die, pre-characterized devices with SKILL/OA/Pycell/Pcells layouts and characterized BSIM spice decks (and maybe macro models) from the PDK vendor alongside novel un-characterized structures which required TCAD simulation and custom layout to design.

Add on top of this that there is no standardized procedural way to arrange and connect these all in layout, and no standardized way to configure a testbench, and no standardized way to run and parse back simulation results...

You could imagine that during the prototyping you could write your own code to produce different layouts, perhaps using GDSTk, etc, but then when you wanted to hand-off your design to future designers, you'd leave them in the dark to either just to import your hardened GDS layouts or manually recreate your layout by inspection, and plus they'd have to create purely lumped element models.

Perhaps the final work output of a front-end pixel design should be a layout PCell which is compiled in OA format (either based on Skill, pycells, or OA script?) and a corresponding compact model which is written in Verilog-A, with some 'current based input pin' for measuring input into the simulator.

One tricky aspect here is that I want to be able to support the netlist formats of HSPICE (so that I can multi-mode sim with Sentarus), the layout tools of Siemens and Cadence (so that other groups can pick up where I leave off) and the GDSII layout format so that I can simulated the charge collection in Sentarus.

It seems in this case that writing to an OA format, where concepts like Pins and named instances are supported. Via Matthias of Klayout:

> concepts like pins and named instances are not part of the GDS and OASIS specification and that still is the basis of the program. It's possible to emulate those features (and others like net information) with user properties, but the interpretation of those is strongly dependent on the tools reading these files.
https://www.klayout.de/forum/discussion/comment/1656#Comment_1656

Figuring out the right way to do this will be tricky. It seems Synopsys has PyCells, which is used by at least LF and also this graphical thing called 'UDD' which appears to be a GUI only front end to OA pcells?

UDD is advertised for power meshes, guard rings, stdcells, custom taps, fillers, decap cells, etc. It looks like it can also existing PCells with added structures, like for example a guard ring on an existing MOSFET pcell. In this presentation Synopsys comments that the alternative would be coding the Pcell in python. Which I guess in a pycell?



This raises the question.... I know Cadence is built around Skill-based cells, allows but doesn't support Pycells..... but what do Synopsys and Siemens do? Does Synopsys really still use Pycells? It and Siemens MUST, right? Because how else would they support PDKs from foundaries?

I need to do more research to understand how this works. Reading TowerJazz docs, LF docs, Synopsys compiler docs, and trying PyCells seems like the only approach here.

The only other functional path forward appears to be writing directly to OA using OAscipt (or BAG???) or using Cadence SKILL to dump layouts produced in python using SKILL bridge.

------------------------------------------

Cadence is the implementation developer of OA, and with IBM as a co-advisor. Si2 is the holder of the licesense.

Michaela Guiney - retired form Cadence in 2022, was the OA change leader, co-authored the Intro to OA paper I read

James Masters - workes at intel for 20 years, developed oaScript and oaxPop

Marshall Tiner - current director of OA internally at Si2. I emailed with him before.

Eric Leavitt - past away in 2018, worked at Cadence with Michaela and was co-author of the paper

Mark Rossman - now the current lead OA change leader at Cadence, to replace Michaela Guiney

Prof. Rhett Davis - NCSU professor, authored FreePDK45 and FreePDK15, tehcnical advisor to Si2. rhett_davis@ncsu.edu



The point of a compact model, whether it is exported from TCAD using Gamard, hard coded with Verilog-A, or simply exported as a IV curve is that the signal is originating from “inside” the device. This means that you can’t expect the circuit to “influence” the signal?

Or can it?

I guess, as long as the device is linear, can’t any curve be modeled?


This is the version of PyCell available with the 1.5 release from Lfoundry:

This is version L-2019.06-SP1 of PyCell Studio.
Packaged on: 2019-8-30

PyCell Studio build with Python version: 2.6.2 (r262:71600, Mar 16 2015, 19:14:39)
[GCC 4.8.3]

cnUtil:
    Changelist #5031540
    Changelist: Change 5015246 on 2019/08/21
    Branch: /slowfs/swe101/PyCell_Studio/clientstore/pycell_p2019.06_dev_qscl/pystudio/santana

Package platform:    plat_linux_gcc483_64
Optimization mode:    opt

Open Access:
  Packages version:
    oaBase:        22.50.011    Tue Nov 11 03:24:55 2014
    oaDM:        22.50.011    Tue Nov 11 03:24:55 2014
    oaTech:        22.50.011    Tue Nov 11 03:24:55 2014
    oaDesign:        22.50.011    Tue Nov 11 03:24:55 2014


This corresponds to RHEL 7 and CentOS 7, which built on gcc 4.8.5 (close enough)

# 3 July 


Program

PyCells


I propose to model and then fabricate a family of test pixels which are designed to the limits of SNR at high frame-rates (100kHZ).

I’d like to try several different variations of pixels, including ones with photogate, photodiode, and collection electrodes, buried diffusion, transfer gates, reset and bias transistors, access transistors,


- Diode and FD layout pcells (portable between tools via PyCells and OA)
- Models for SPICE simulation, via tuned diode and parasitics “macro model” or via Verilog-A. Verified via TCAD device mixed-mode simulation, and measurment. Generated via HDL21?
- Layout


I’ve looked at:

- Device level simulation for sensors (TCAD Synopsys, CASINO, Allpix2 +Geant)
- Device level layout: Skill Pcells, PyCells, T-Cells in C++ or via GUI, Custom via Python. The first two allow OA and callbacks. Only the first isn’t portable between tools. The latter ones don’t allow callback integration, and are less integrated.
- Device level compact models: Macro models, Verilog-A, multimode TCAD+SPICE (slow and limited as it doesn’t use normal EDA tools). Circuit generators are good here, as I won’t want to write to OA files anyways because LVS won’t run at this level and SPICE decks are the norm for macro modeling.
- Circuit-level netlist creation: Relies on all devices being characterized/modeled. Graphical netlist entry doesn’t support good parametrization/automation. But the few choices I’ve tried either don’t support OA (Hdl21 and substrate) or they are impossible to setup (BAG2/3). I think schematics are less important to automate,
- Circuit level layout: relies on hardened devices layouts or wrapped pcells, different approaches but procedural with templates is probably best for compactness vs LOC trade off. Templating and relative placement, informed by DRs also allows some degree of process portability.
- Finally testbenches and simulation can also be generated (by Hdl21,BAG,substrate) but I’m not sure this is worth it


Syncing: If I wanted to generate both layouts and schematics, I would run into the following issues:

- PDKs provided technology files will need to be translated to Santana file format for PyCells.
- PyCells layout will need to be exported to GDS, then imported to sprocess?
- Do we even have the Python API license for Sentarus?
- Fitting a macro model to the process simulation is the best next step, but will require additional Python steps, plus a library (Hdl21??) for generating netlist SPICE deck. (I think Verilog-A is too much work). Perhaps there is a simpler way to
- I will need to develop an analytic model of the sensor and transistor, to rationalize the system to myself.
- For circuit level schematic design: two sources of truth for the layout and schematic dimension parameters will be annoying but probably likely? Schematics are somewhat parametrizable, but not in a way that could then easily feed dimensions to a layout, I believe also the layout will probably have variations not included in the schematic?
- Hdl21 or Substrate would require writing a PDK wrapper package to netlist PDK devices.
- Hdl21 or Substrate would require a library for HSPICE or T-SPICE TB netlisting, simulation options, and parsing, depending on what Caeleste is using and wants