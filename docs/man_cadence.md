# Cadence notes

This document provides notes on how to interact with Cadence Virtuoso and Spectre in a automatic manner. File formats and purposes, plus available commandline utilities are provided.


## SI
- `si.env` is the profile of the simulation environment, you can check ADE->setup->environment. It also controls netlisting (for e.g. with the cdl netlister)
- `si myTemp -batch -command netlist -cdslib cds.lib`


## Spectre

Despite using `spectre`, we will opt to use the widely compatible `nutbin` format, which is a binary file following the original SPICE3 nutmeg format. It is perhaps a bit less compact than `psfbin` files, but can be read by tools other than Cadence's Viva. This is also simply called a `raw` file by other tools, likes `ngspice`.


Spectre supports output files of nutbin, nutascii, psfbin, psfascii, psfbinf, psfxl, sst2, fsdb, fsdb5, wdf, uwi, and tr0ascii.

Nutbin/ascii are SPICE3 standard formats, and PSF stands for "parameter storage format"

The following simulation types are available:

```
normal: ac, dc, noise sp, stb, xf, tran
hb:     ac, noise, sp, stb, xf
p:	ac, noise, sp, ss, stb, xf
qp:	ac, noise, sp, ss, xf
```

Note: The hb, p, and qp analysis flavors aren't available in AMS Designer

Spectre help gives information on: components, analysis + control statements, circuit checks, ahdllink, etc.

## AMS Simulator

Spectre AMS connect connects the uniform timestep SPICE/Spectre Simulator with an event based Xcelium simulator. It uses a 'tight coupling' with shared memory, over a more basic isolated interprocess communication model.

Two ways to run AMS Design/Simulator:
1) AVUM for GUI (from Virtuoso)
2) AXUM for command line (from Xcelium command line)

In the Virtuoso use model, config views are used to select the cellview for each cell.


## Summary of SKILL, Ocean, MDL, CDL, files

- CDL is just a subset of SPICE netlists, primarily used during LVS. It's generated by CDLout. auCDL stands for analog and microwave circuit description language.
- OCEAN is tied to Virtuoso ADE, so requires the Cadence runtime. But it also works with any underlying simulator, not just Spectre. It's essentially just a library of SKILL. And it has the addition of OCEANXL for ADE Assembler.
- MDL is run within the simulator - as such, this means that it's well-suited for a command-line Spectre user as the approach is quite Spectre-like and doesn't need you to use a larger executable such as Virtuoso to control/post-process your results
- MDL can also be used to make measurements during simulation, and auto-stop when they've been met - so for characterisation tasks (such as setup/hold) this can be more efficient
- MDL also gives access to some simple search and multi-variable optimisation within the simulator - so whilst not as powerful as the optimisers in ADE, it's much faster
- MDL is however quite limited in the functions available, and doesn't really handle things like RF analyses.
- OCEAN is more extendable, but is very much a means of controlling whole simulations and analysing the results from whole simulations. Because OCEAN is just a set of SKILL functions, the language has not been designed specifically with simulation in mind and so it can appear a little clunky compared with MDL which was designed specifically for the purposes of making measurements in simulation - although SKILL has the upside that comes from being a pretty broad programming language.
- OCEAN tends to be more natural for somebody used to using ADE as it fits alongside ADE (it's using the ADE infrastructure underneath).
- So there are pluses and minuses of both - which is why both exist. Historically, OCEAN has been around for longer, and when MDL was first created there was a thought that it would replace OCEAN for calculations, doing measurement-centric simulation and so on - but in practice the need for legacy support and also the fact that MDL was specific to Spectre meant that didn't quite pan out. Some may remember in the past that the waveform tool at the time, wavescan, initially was for MDL, then extended to have two language modes, and finally dropped the MDL mode.

## Files notes:

Library manager obtains form settings from the `.cdsenv` file only and not from the `.cdsinit` file.

The Library Manager searches for the `.cdsenv` file in the following locations, in the specified order:

- install_dir/tools/dfII/etc/tools/cdsLibManager (This file contains the default settings.)
- install_dir/tools/dfII/local
- $HOME
- $CWD
Virtuoso does not look for the `.cdsenv` file in the current directory by default, although the Library Manager does.

## Attaching technology libraries:
- Any library can either reference a technology library or attach to a technology library. A design library must do one or the other to have access to technology data during a design session. A technology library can also reference or attach to another technology library; alternatively, it can be standalone by doing neither, using only the cdsDefTechLib default technology data. Choosing whether to reference or attach a technology library depends upon whether or not designers need to specify technology data during their design sessions.
- Referencing a technology database from a design library or another technology library protects the integrity of any read-only data in the effective technology library while providing a writable local library where designers can define technology data. Referencing is preferable to attachment when designers need a writable local technology database in which to add technology data (such as data output by LEFIN).
- Attaching is preferable in cases where designers use only predefined technology data, which is typically read-only.


In this case, all TOWER designs should *attach* the ts018_prim library, as it contains:

../ts18is_Rev_6.3.6/HOTCODE/amslibs/cds_oa/cdslibs/ts18sl/devices/ts018_oa_compana_6M1L/6.2/ref_libs/ts018_prim/tech.db

virtuoso ascii technology file -> openaccess tech db
(compiled with virtuoso technology file manager)

## techfiles:
tech.db are imported cadence specific version of .tech/.tf techfiles

## layer information:
.layermap are used for input output streaming
display.drf provides colors for the layers


## Virtuoso CIW:

To load an external skill file:

```
ddUpdateLibList()
load("~/frida/build/test_tsmc65_lay.il")
```

From this I learned two other things: UDD input params are also called CDF params (component description format), like in Cadence. CDF is the Cadence front end for giving the GUI-user access to the parameters to pass to the simulation model and pcell. But CDF is seperate, and has to have values that match the range, quantization, and defaults of the models/pcells. CDF appears to work as a application level system component which can be interacted with via SKILL. It's the mesh layer internal to Cadence which connects pcells, simulators, models, netlists, etc and let's the user interactively modify the settings and connections between them in the GUI.

The following code can be used to export valid layers and purposes from Virtuoso's CIW:

```
techid=techGetTechFile(ddGetObj("tsmcN65"))
techGetMfgGridResolution(techid)
techGetDBUPerUU(techid "maskLayout")
let((laylist) foreach(layer techid->layers laylist=cons(list(layer->name layer->number) laylist)) laylist)
let((purplist) foreach(purp techid->purposeDefs purplist=cons(list(purp->name purp->number) purplist)) purplist)
let((vialist) foreach(via techid->viaDefs vialist=cons(list(via->name via->layer1Num via->layer2Num via->params) vialist)) vialist)
```

## Parasitic extraction

Parasitic extraction yeilds something called a DSPF file, or Detailed Standard Parasitic Format
It's a spice netlists generated by StarRC, QRC, Calibre, etc which is directly simulatable with design devices and parasitic devices
It's not a standardized format, unlike [SPEF](https://en.wikipedia.org/wiki/Standard_Parasitic_Exchange_Format) which is IEEE standardized

# OpenAccess
- OpenAccess can store layout data, schematics, symbols, netlists and any other application specific data. These information are stored into many files in a directory tree.
- oaTech.db for foundry-specific layer information. This includes grids, connectivity, display information, and version information.


# Example of a skill script used for generating a complex geometry in SKILL:

```skill
gdssLibName = "test_tsmc65"
 pdkLib = "test_tsmc65"
;- Create cell SARKICKHX1_EV
(let (layout net fig )
 layout = dbOpenCellViewByType(gdssLibName "SARKICKHX1_EV" "layout" "maskLayout" "w")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN0" 0.0:0.0 "R0")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN1" 0.0:1.08 "R0")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN2" 0.0:2.16 "R0")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN3" 0.0:3.24 "R0")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN4" 0.0:4.32 "R0")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN5" 0.0:5.4 "R0")
mstr = dbOpenCellViewByType( pdkLib "NCHDL" "layout")
layInst=dbCreateInst(layout mstr "MN6" 0.0:6.48 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP0" 1.89:0.0 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP1_DMY" 1.89:1.08 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP2_DMY" 1.89:2.16 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP3_DMY" 1.89:3.24 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP4_DMY" 1.89:4.32 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP5_DMY" 1.89:5.4 "R0")
mstr = dbOpenCellViewByType( pdkLib "PCHDL" "layout")
layInst=dbCreateInst(layout mstr "MP6" 1.89:6.48 "R0")
fig = dbCreateRect(layout list(31 255) list(1.23:0.69 1.29:6.87))
dbCreateLabel(layout list(240 255) 1.08:0.69 "N1" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(1.26:0.69 1.53:0.75))
fig = dbCreateRect(layout list(31 255) list(1.53:0.33 2.52:0.39))
fig = dbCreateRect(layout list(31 255) list(1.53:0.33 1.59:0.75))
dbCreateLabel(layout list(240 255) 1.08:0.69 "N1" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(0.6:1.59 0.66:5.97))
dbCreateLabel(layout list(240 255) 0.45:1.59 "CI" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(17 255) list(0.54:0.45 3.24:0.63))
dbCreateLabel(layout list(240 255) 0.54:0.45 "CKN" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(3.12:1.59 3.18:7.05))
dbCreateLabel(layout list(240 255) 2.97:1.59 "NC" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(2.49:1.41 2.55:7.23))
dbCreateLabel(layout list(240 255) 2.34:1.41 "NC" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(1.08:7.17 2.7:7.23))
dbCreateLabel(layout list(240 255) 1.08:7.17 "NC" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(2.52:7.17 2.79:7.23))
fig = dbCreateRect(layout list(31 255) list(2.79:6.99 3.15:7.05))
fig = dbCreateRect(layout list(31 255) list(2.79:6.99 2.85:7.23))
dbCreateLabel(layout list(240 255) 2.34:7.17 "NC" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(0.45:6.99 0.81:7.05))
net = dbCreateNet(layout "CK")
dbCreateTerm( net "CK" "inputOutput")
dbCreatePin(net fig)
dbCreateLabel(layout list(31 251) 0.45:6.99 "CK" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(0.45:0.51 0.81:0.57))
net = dbCreateNet(layout "CKN")
dbCreateTerm( net "CKN" "inputOutput")
dbCreatePin(net fig)
dbCreateLabel(layout list(31 251) 0.45:0.51 "CKN" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(31 255) list(0.45:1.59 0.81:1.65))
net = dbCreateNet(layout "CI")
dbCreateTerm( net "CI" "inputOutput")
dbCreatePin(net fig)
dbCreateLabel(layout list(31 251) 0.45:1.59 "CI" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(34 255) list(2.34:0.0 2.67:7.56))
net = dbCreateNet(layout "AVDD")
dbCreateTerm( net "AVDD" "inputOutput")
dbCreatePin(net fig)
dbCreateLabel(layout list(34 251) 2.34:0.0 "AVDD" "centerLeft" "R0" "stick" 0.1)
fig = dbCreateRect(layout list(34 255) list(1.08:0.0 1.41:7.56))
net = dbCreateNet(layout "AVSS")
dbCreateTerm( net "AVSS" "inputOutput")
dbCreatePin(net fig)
dbCreateLabel(layout list(34 251) 1.08:0.0 "AVSS" "centerLeft" "R0" "stick" 0.1)
mstr = dbOpenCellViewByType( pdkLib "cut_M1M4_2x1" "layout")
layInst=dbCreateInst(layout mstr "" 2.34:0.69 "R0")
mstr = dbOpenCellViewByType( pdkLib "cut_M1M4_2x1" "layout")
layInst=dbCreateInst(layout mstr "" 2.34:7.17 "R0")
mstr = dbOpenCellViewByType( pdkLib "cut_M1M4_2x1" "layout")
layInst=dbCreateInst(layout mstr "" 2.34:6.81 "R0")
fig = dbCreateRect(layout list(34 255) list(2.34:0.0 2.67:7.56))
mstr = dbOpenCellViewByType( pdkLib "cut_M1M4_2x1" "layout")
layInst=dbCreateInst(layout mstr "" 1.08:0.33 "R0")
fig = dbCreateRect(layout list(34 255) list(1.08:0.0 1.41:7.56))
 dbSave(layout) )
```
